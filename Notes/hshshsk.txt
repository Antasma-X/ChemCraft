CC=g++
Cflags= -Wall -g --std=c++17 
LIB = build/imgui.o

all: main

main: build/element.o build/values.o build/main.o build/compound.o build/molecules.o
	$(CC) $(Cflags) -o $@ $^

cute: build/element.o build/values.o build/test.o build/compound.o build/molecules.o
	$(CC) $(Cflags) -o $@ $^

build/element.o: src/element.cpp
	$(CC) $(Cflags) -o $@ -c $^

build/values.o: src/values.cpp
	$(CC) $(Cflags) -o $@ -c $^

build/compound.o: src/compound.cpp
	$(CC) $(Cflags) -o $@ -c $^

build/test.o: test/test.cpp
	$(CC) $(Cflags) -o $@ -c $^

build/imgui.o: lib/imgui/src/imgui_demo.cpp lib/imgui/src/imgui_draw.cpp lib/imgui/src/imgui/imgui_impl_glfw.cpp lib/imgui/src/imgui_opengl3.cpp lib/imgui/src/imgui_tables.cpp lib/imgui/src/imgui_widgets.cpp lib/imgui/src/imgui.cpp
	$(CC) $(Cflags) -o $@ -c $^
build/molecules.o: src/molecules.cpp
	$(CC) $(Cflags) -o $@ -c $^
clean:
	rm build/*.o main cute

test:

lib/imgui/src/imgui/imgui_impl_glfw.cpplib/imgui/src/imgui_opengl3.cpp

imgui_demo.cpp imgui_draw.cpp imgui_impl_glfw.cpp imgui_impl_opengl3.cpp imgui_tables.cpp imgui_widgets.cpp imgui.cpp

target_include_directories(imgui 
    INTERFACE
    ${CMAKE_CURRENT_SOURCE_DIR})

// Compound* makeMolecule(std::string name){
//     return makeMolecule(molecules[name]);
// }

// Compound* makeMolecule(int n){

//     Compound* newCompound=nullptr;
    
//     if(n==1){
//         Element* H1=new Element(1);
//         Element* H2=new Element(1);
//         Element* O=new Element(8);

//         newCompound=new Compound(*H1);
//         newCompound->addElement(*H1,*O,0);
//         newCompound->addElement(*O,*H2,0);
        
//     }
//     else if(n==2){
//         Element* O1=new Element(8);
//         Element* O2=new Element(8);
//         Element* C=new Element(6);            

//         newCompound=new Compound(*C);
//         newCompound->addElement(*C,*O1,0);
//         newCompound->addElement(*C,*O2,0);
//     }
//     else if(n==3){
//         Element* O=new Element(8);
//         Element* C=new Element(6);            

//         newCompound=new Compound(*C);
//         newCompound->addElement(*C,*O,0);
//     } 
//     else if(n==4){
//         Element* H1=new Element(1);
//         Element* H2=new Element(1);
//         Element* O1=new Element(8);
//         Element* O2=new Element(8);

//         newCompound=new Compound(*H1);
//         newCompound->addElement(*H1,*O1,0);
//         newCompound->addElement(*O1,*O2,0);
//         newCompound->addElement(*O2,*H2,0);
//     }
//     else if(n==5){
//         Element* O1=new Element(8);
//         Element* O2=new Element(8);
//         Element* O3=new Element(8);

//         newCompound=new Compound(*O1);
//         newCompound->addElement(*O1,*O2,0);
//         newCompound->addElement(*O2,*O3,0);
//         newCompound->createBond(*O1,*O3,0);
//     }
//     else if(n==6){
//         Element* N=new Element(7);
//         Element* H1=new Element(1);
//         Element* H2=new Element(1);
//         Element* H3=new Element(1);

//         newCompound=new Compound(*N);
//         newCompound->addElement(*N,*H1,0);
//         newCompound->addElement(*N,*H2,0);
//         newCompound->addElement(*N,*H3,0);
//     }
//     else if(n==7){
//         Element* N=new Element(7);
//         Element* O1=new Element(8);
//         Element* O2=new Element(8);

//         newCompound=new Compound(*N);
//         newCompound->addElement(*N,*O1,0);
//         newCompound->addElement(*N,*O2,0);
//         newCompound->createBond(*N,*O1,0);         
//     }
//     else if(n==8){
//         Element* C1=new Element(6);
//         Element* C2=new Element(6);
//         Element* C3=new Element(6);
//         Element* C4=new Element(6);
//         Element* C5=new Element(6);
//         Element* C6=new Element(6);

//         Element* H1=new Element(1);
//         Element* H2=new Element(1);
//         Element* H3=new Element(1);
//         Element* H4=new Element(1);
//         Element* H5=new Element(1);
//         Element* H6=new Element(1);

//         newCompound=new Compound(*C1);
//         newCompound->addElement(*C1,*C2,0);
//         newCompound->addElement(*C2,*C3,0);
//         newCompound->addElement(*C3,*C4,0);
//         newCompound->addElement(*C4,*C5,0);
//         newCompound->addElement(*C5,*C6,0);

//         newCompound->createBond(*C2,*C3,0);
//         newCompound->createBond(*C4,*C5,0);
//         newCompound->createBond(*C6,*C1,0);

//         newCompound->addElement(*C1,*H1,0);
//         newCompound->addElement(*C2,*H2,0);
//         newCompound->addElement(*C3,*H3,0);
//         newCompound->addElement(*C4,*H4,0);
//         newCompound->addElement(*C5,*H5,0);
//         newCompound->addElement(*C6,*H6,0);
//     }
//     else{
        
//     }
//     return newCompound;
    
// }


// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeAnion(std::string name){
//     return makeAnion(anions[name]);
// }

// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeAnion(int n){
//     Compound* newCompound=nullptr;
//     std::vector<Element*> elements;
//     std::vector<int> valencies;
    
//     if(n==1){
//         Element* F= new Element(9);

//         elements.emplace_back(F);
//         valencies.emplace_back(-1);

//         newCompound= new Compound(*F);
//     }
//     else if(n==2){
//         Element* Cl= new Element(17);

//         elements.emplace_back(Cl);
//         valencies.emplace_back(-1);

//         newCompound= new Compound(*Cl);
//     }
//     else if(n==3){
//         Element* Br= new Element(35);

//         elements.emplace_back(Br);
//         valencies.emplace_back(-1);

//         newCompound= new Compound(*Br);
//     }
//     else if(n==4){
//         Element* I= new Element(53);

//         elements.emplace_back(I);
//         valencies.emplace_back(-1);

//         newCompound= new Compound(*I);
//     }
//     else if(n==5){
//         Element* S = new Element(16);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);
//         Element* O3 = new Element(8);
//         Element* O4 = new Element(8);

//         newCompound=new Compound(*S);
//         newCompound->addElement(*S,*O1,0);
//         newCompound->addElement(*S,*O2,0);
//         newCompound->addElement(*S,*O3,0);
//         newCompound->addElement(*S,*O4,0);

//         newCompound->createBond(*S,*O2,0);
//         newCompound->createBond(*S,*O4,0);

//         elements.emplace_back(O1);
//         valencies.emplace_back(-1);

//         elements.emplace_back(O3);
//         valencies.emplace_back(-1);
//     }
//     else if(n==6){
//         Element* S = new Element(16);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);
//         Element* O3 = new Element(8);

//         newCompound=new Compound(*S);
//         newCompound->addElement(*S,*O1,0);
//         newCompound->addElement(*S,*O2,0);
//         newCompound->addElement(*S,*O3,0);

//         newCompound->createBond(*S,*O2,0);

//         elements.emplace_back(O1);
//         valencies.emplace_back(-1);

//         elements.emplace_back(O3);
//         valencies.emplace_back(-1);
        
//     }
//     else if(n==7){
//         Element* C = new Element(6);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);
//         Element* O3 = new Element(8);

//         newCompound=new Compound(*C);
//         newCompound->addElement(*C,*O1,0);
//         newCompound->addElement(*C,*O2,0);
//         newCompound->addElement(*C,*O3,0);
//         newCompound->createBond(*C,*O2,0);

//         elements.emplace_back(O1);
//         valencies.emplace_back(-1);

//         elements.emplace_back(O3);
//         valencies.emplace_back(-1);
//     }
//     else if(n==8){
//         Element* C = new Element(6);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);
//         Element* O3 = new Element(8);
//         Element* H = new Element(1);

//         newCompound=new Compound(*C);
//         newCompound->addElement(*C,*O1,0);
//         newCompound->addElement(*C,*O2,0);
//         newCompound->addElement(*C,*O3,0);
//         newCompound->addElement(*O1,*H,0);
//         newCompound->createBond(*C,*O2,0);     

//         elements.emplace_back(O3);
//         valencies.emplace_back(-1);
//     }
//     else if(n==9){
//         Element* N = new Element(7);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);
//         Element* O3 = new Element(8);

//         newCompound=new Compound(*N);
//         newCompound->addElement(*N,*O1,0);
//         newCompound->addElement(*N,*O2,0);
//         newCompound->addElement(*N,*O3,0);
//         newCompound->createBond(*N,*O2,0);

//         elements.emplace_back(O3);
//         valencies.emplace_back(-1);
//     }
//     else if(n==10){
//         Element* N = new Element(7);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);

//         newCompound=new Compound(*N);
//         newCompound->addElement(*N,*O1,0);
//         newCompound->addElement(*N,*O2,0);
//         newCompound->createBond(*N,*O2,0);       

//         elements.emplace_back(O1);
//         valencies.emplace_back(-1);
//     }
//     else if(n==11){
//         Element* P = new Element(15);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);
//         Element* O3 = new Element(8);
//         Element* O4= new Element(8);

//         newCompound=new Compound(*P);
//         newCompound->addElement(*P,*O1,0);
//         newCompound->addElement(*P,*O2,0);
//         newCompound->addElement(*P,*O3,0);
//         newCompound->addElement(*P,*O4,0);
//         newCompound->createBond(*P,*O4,0);           

//         elements.emplace_back(O1);
//         valencies.emplace_back(-1);

//         elements.emplace_back(O2);
//         valencies.emplace_back(-1);

//         elements.emplace_back(O3);
//         valencies.emplace_back(-1);
//     }
//     else if(n==12){
//         Element* P = new Element(15);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);
//         Element* O3 = new Element(8);


//         newCompound=new Compound(*P);
//         newCompound->addElement(*P,*O1,0);
//         newCompound->addElement(*P,*O2,0);
//         newCompound->addElement(*P,*O3,0);

//         elements.emplace_back(O1);
//         valencies.emplace_back(-1);

//         elements.emplace_back(O2);
//         valencies.emplace_back(-1);

//         elements.emplace_back(O3);
//         valencies.emplace_back(-1);
//     }
//     else if(n==13){
//         Element* O = new Element(8);
//         Element* H = new Element(1);  
//         newCompound=new Compound(*O);
//         newCompound->addElement(*O,*H,0);         

//         elements.emplace_back(O);
//         valencies.emplace_back(-1);
//     }
//     else{
//         //error
//     }


    
//     std::pair<Compound*,std::vector<std::pair<Element*,int>>> info;
//     info.first=newCompound;

// //     for(std::size_t i=0;i<elements.size();i++){
// //         info.second[i]=std::make_pair(elements[i],valencies[i]);
// //     }
    
// //     return info;
// // }


// Compound* makeAnion(int n){
//         Compound* newCompound=nullptr;
        
//         if(n==1){
//             Element* F= new Element(9);
    
//             elements.emplace_back(F);
//             valencies.emplace_back(-1);
    
//             newCompound= new Compound(*F);
//         }
//         else if(n==2){
//             Element* Cl= new Element(17);
    
//             elements.emplace_back(Cl);
//             valencies.emplace_back(-1);
    
//             newCompound= new Compound(*Cl);
//         }
//         else if(n==3){
//             Element* Br= new Element(35);
    
//             elements.emplace_back(Br);
//             valencies.emplace_back(-1);
    
//             newCompound= new Compound(*Br);
//         }
//         else if(n==4){
//             Element* I= new Element(53);
    
//             elements.emplace_back(I);
//             valencies.emplace_back(-1);
    
//             newCompound= new Compound(*I);
//         }
//         else if(n==5){
//             Element* S = new Element(16);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
//             Element* O3 = new Element(8);
//             Element* O4 = new Element(8);
    
//             newCompound=new Compound(*S);
//             newCompound->addElement(*S,*O1,0);
//             newCompound->addElement(*S,*O2,0);
//             newCompound->addElement(*S,*O3,0);
//             newCompound->addElement(*S,*O4,0);
    
//             newCompound->createBond(*S,*O2,0);
//             newCompound->createBond(*S,*O4,0);
    
//             elements.emplace_back(O1);
//             valencies.emplace_back(-1);
    
//             elements.emplace_back(O3);
//             valencies.emplace_back(-1);
//         }
//         else if(n==6){
//             Element* S = new Element(16);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
//             Element* O3 = new Element(8);
    
//             newCompound=new Compound(*S);
//             newCompound->addElement(*S,*O1,0);
//             newCompound->addElement(*S,*O2,0);
//             newCompound->addElement(*S,*O3,0);
    
//             newCompound->createBond(*S,*O2,0);
    
//             elements.emplace_back(O1);
//             valencies.emplace_back(-1);
    
//             elements.emplace_back(O3);
//             valencies.emplace_back(-1);
            
//         }
//         else if(n==7){
//             Element* C = new Element(6);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
//             Element* O3 = new Element(8);
    
//             newCompound=new Compound(*C);
//             newCompound->addElement(*C,*O1,0);
//             newCompound->addElement(*C,*O2,0);
//             newCompound->addElement(*C,*O3,0);
//             newCompound->createBond(*C,*O2,0);
    
//             elements.emplace_back(O1);
//             valencies.emplace_back(-1);
    
//             elements.emplace_back(O3);
//             valencies.emplace_back(-1);
//         }
//         else if(n==8){
//             Element* C = new Element(6);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
//             Element* O3 = new Element(8);
//             Element* H = new Element(1);
    
//             newCompound=new Compound(*C);
//             newCompound->addElement(*C,*O1,0);
//             newCompound->addElement(*C,*O2,0);
//             newCompound->addElement(*C,*O3,0);
//             newCompound->addElement(*O1,*H,0);
//             newCompound->createBond(*C,*O2,0);     
    
//             elements.emplace_back(O3);
//             valencies.emplace_back(-1);
//         }
//         else if(n==9){
//             Element* N = new Element(7);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
//             Element* O3 = new Element(8);
    
//             newCompound=new Compound(*N);
//             newCompound->addElement(*N,*O1,0);
//             newCompound->addElement(*N,*O2,0);
//             newCompound->addElement(*N,*O3,0);
//             newCompound->createBond(*N,*O2,0);
    
//             elements.emplace_back(O3);
//             valencies.emplace_back(-1);
//         }
//         else if(n==10){
//             Element* N = new Element(7);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
    
//             newCompound=new Compound(*N);
//             newCompound->addElement(*N,*O1,0);
//             newCompound->addElement(*N,*O2,0);
//             newCompound->createBond(*N,*O2,0);       
    
//             elements.emplace_back(O1);
//             valencies.emplace_back(-1);
//         }
//         else if(n==11){
//             Element* P = new Element(15);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
//             Element* O3 = new Element(8);
//             Element* O4= new Element(8);
    
//             newCompound=new Compound(*P);
//             newCompound->addElement(*P,*O1,0);
//             newCompound->addElement(*P,*O2,0);
//             newCompound->addElement(*P,*O3,0);
//             newCompound->addElement(*P,*O4,0);
//             newCompound->createBond(*P,*O4,0);           
    
//             elements.emplace_back(O1);
//             valencies.emplace_back(-1);
    
//             elements.emplace_back(O2);
//             valencies.emplace_back(-1);
    
//             elements.emplace_back(O3);
//             valencies.emplace_back(-1);
//         }
//         else if(n==12){
//             Element* P = new Element(15);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
//             Element* O3 = new Element(8);
    
    
//             newCompound=new Compound(*P);
//             newCompound->addElement(*P,*O1,0);
//             newCompound->addElement(*P,*O2,0);
//             newCompound->addElement(*P,*O3,0);
    
//             elements.emplace_back(O1);
//             valencies.emplace_back(-1);
    
//             elements.emplace_back(O2);
//             valencies.emplace_back(-1);
    
//             elements.emplace_back(O3);
//             valencies.emplace_back(-1);
//         }
//         else if(n==13){
//             Element* O = new Element(8);
//             Element* H = new Element(1);  
//             newCompound=new Compound(*O);
//             newCompound->addElement(*O,*H,0);         
    
//             elements.emplace_back(O);
//             valencies.emplace_back(-1);
//         }
//         else{
//             //error
//         }
    
    
        
//         std::pair<Compound*,std::vector<std::pair<Element*,int>>> info;
//         info.first=newCompound;
    
// //         for(std::size_t i=0;i<elements.size();i++){
// //             info.second[i]=std::make_pair(elements[i],valencies[i]);
// //         }
        
// //         return info;
// //     }

// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeCation(std::string name,int valency){

//     auto it=std::find(names.begin(),names.end(),name);
//     int n;
//     if(it==names.end()){
//         auto i=cations.find(name);
//         if(i == cations.end()){
//             n=0;

//         }
//         else{
//             n=std::distance(cations.begin(),i)+1;
//         }
//     }
//     else{
//         n=std::distance(names.begin(),it)+1;

//     }
//     return makeCation(n,valency);
// }

// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeCation(int n,int valency){
//     Compound* newCompound=nullptr;
//     std::vector<Element*> elements;
//     std::vector<int> valencies;

//     if(n>=1 && n<=118){
//         Element* element1=new Element(n);
//         newCompound=new Compound(*element1);

//         elements.emplace_back(element1);
//         valencies.emplace_back(valency);
//     }
//     else{
//         // switch(n){
//         //     case 200:
//         //         //ammonium
//         //     case 201:
//         //     //hydronium
//         // }
//     }
//         std::pair<Compound*,std::vector<std::pair<Element*,int>>> info;
//     info.first=newCompound;

//     for(size_t i=0;i<elements.size();i++){
//         info.second[i]=std::make_pair(elements[i],valencies[i]);
//     }

    
//     return info;
// }

// std::array<std::string,3> splitSaltName(std::string name){
//     std::array<std::string,3> sections;
//     int i =0;
//     std::string space=" ";
//     for(int j=0;j<3;j++){
//         while(name[i] !=' '){
//             sections[i]+=name[i];
//             i++;
//         }
//         i++;
//     }
//     return sections;
// }

// //yoink
// int value(char r)
// {
//     if (r == 'I')
//         return 1;
//     if (r == 'V')
//         return 5;
//     if (r == 'X')
//         return 10;
//     if (r == 'L')
//         return 50;
//     if (r == 'C')
//         return 100;
//     if (r == 'D')
//         return 500;
//     if (r == 'M')
//         return 1000;
 
//     return -1;
// }
 



// Compound* makeSalt(std::string name){
//     std::array<std::string,3> sections=splitSaltName(name);
//     int n=romanToDecimal(sections[1]);

//     std::pair<Compound*,std::vector<std::pair<Element*,int>>> anion= makeAnion(sections[2]);
//     std::pair<Compound*,std::vector<std::pair<Element*,int>>> cation=makeCation(sections[0],n);

//     int totalAnionValency=0;
//     int totalCationValency=0;

//     for(auto el:anion.second){
//         totalAnionValency+=el.second;
//     }

//     for(auto el:cation.second){
//         totalCationValency+=el.second;
//     }

//     int lcm=std::lcm(abs(totalAnionValency),totalCationValency);

//     std::vector<std::pair<Compound*,std::vector<std::pair<Element*,int>>>> anions={anion};
//     std::vector<std::pair<Compound*,std::vector<std::pair<Element*,int>>>> cations={cation};

//     for(int i=0;i<(lcm/totalCationValency)-1;i++){
//         cations.emplace_back(makeCation(sections[0],n));
//     }

//     for(int i=0;i<(lcm/abs(totalAnionValency))-1;i++){
//         anions.emplace_back(makeAnion(sections[0]));
//     }


//     //code is built on hopes and prayers
//     int i=0;
//     int j=0;
//     size_t k=0;

//     for(auto anion:anions){
//         for(int l=0;l<abs(totalAnionValency);i++){
//             if(anion.second[i].second !=0){
                
//                 anion.second[i].second++;
//                 cations[j].second[k].second--;
//                 anion.first->addElement(*anion.second[i].first,*cations[j].second[k].first,*cations[j].first,-1);

//                 while (true){
//                     if(cations[j].second[k].second==0){
//                         if(cations[j].second.size()==k-1){
//                             j++;
//                             k=0;
//                         }
//                         else{
//                             k++;
//                         }
//                     }
//                     else{
//                         break;
//                     }
//                 }
//             }
//             else{
//                 i++;
//             }
//         }
//     }

//     return anion.first;
// }



// Compound* makeMolecule(int n);



// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeAnion(std::string name);

// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeAnion(int n);

// //1-118 for elelemnts than actual ions
// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeCation(std::string name,int valency);

// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeCation(int n,int valency);

//stock notation



// std::map<std::string,int> molecules={
//     {"Water",1},
//     {"Carbon Dioxide",2},
//     {"Carbon Monoxide",3},
//     {"Hydrogen Peroxide",4},
//     {"Ozone",5},
//     {"Ammonia",6},
//     {"Nitrogen Dioxide", 7},
//     {"Benzene",8}

// };

        // std::cout<<io.DisplaySize.y<<std::endl;
        // if(prevWindowSize.y!=io.DisplaySize.y){
        //     io.Fonts->Clear(); 
        //     io.Fonts->AddFontFromFileTTF("/mnt/c/Windows/Fonts/arial.ttf", 18.0f);
        //     myFont= io.Fonts->AddFontFromFileTTF("/mnt/c/Windows/Fonts/arial.ttf", searchBarHeightPerCent*io.DisplaySize.y);
        //     io.Fonts->Build();
        //     ImGui_ImplOpenGL3_DestroyFontsTexture();
        //     ImGui_ImplOpenGL3_CreateFontsTexture();
        // }
        




// Compound::Compound(Compound&& other) {
//         atoms=other.atoms;
// 		bonds=other.bonds;
//     }

// Compound::Compound(const Compound& other){
// 	atoms=other.atoms;
// 	bonds=other.bonds;
// }

// class CompoundObject{
//     Compound* compound;
//     std::vector<ElementObject*> ElObjs;
//     // std::vector<rect> covalentBonds;
//     // std::vector<rect> dativeBonds;
//     // std::vector<int> charges;
//     // std::vector<int> ionicBonds;
//     //dont render bond in element
//     //also somehow lock distance
    
//     static std::vector<CompoundObject*> compoundsOnScreen;

//     void drawCompounds();

//     void drawCompound();

//     void drawbonds();

//     public:
//     CompoundObject(std::string compoundString);

//     CompoundObject(int atomicNumber, double atomicMass=0,int charge=0);

//     CompoundObject(int compoundNumber,char dummy);

//     CompoundObject(Compound* compound);

//     ~CompoundObject();

//     CompoundObject()=delete;

//     static std::vector<CompoundObject*> getListOfCompoundObjects();

// //any list should the original check lost every framw 


// };

#ifndef ELEMENT_RENDER_H
#define ELEMENT_RENDER_H

#include "GUIDependencies.h"
#include "StdLibDependencies.h"
#include "element.h"

class ElementObject{
    Element* element;
    // static std::vector<Element*> elementsOnScreen;
    // std::array<ImVec2,8> valenceElectrons;

    // std::array<ImVec2,4> dativeBonds;
    // std::array<ImVec2,4> dativeBondsLocations;

    // int ionicBond;
    // bool upIonic;
    //elemeny object will just render
    //std::array<ImVec2,8> ionicBondsLocations;

    std::array<GLfloat,8> vertices;
    vertvies array;
    texture array;
    //create dots

    public:
    //ElementObject(int atomicNumber, double atomicMass=0, int valency=0);

    ElementObject(Element* element);

    void drawElement();

    void drawElectronsAndBondsOfElement();

    void Inserelementiselementobject();
    //electrons
    //staus of bonds
    //
};
 

#endif

#include "compoundRender.h"

void CompoundObject::drawCompounds(){

}

void CompoundObject::drawCompound(){

}

CompoundObject::CompoundObject(std::string compoundString){

}

CompoundObject::CompoundObject(int atomicNumber, double atomicMass,int charge){
    compound=new Compound(atomicNumber,atomicMass,charge);

    for(auto atom: compound->getAtoms()){
        ElementObject* elObj=new ElementObject(atom);
        ElObjs.push_back(elObj);
    }

    for(auto [el,bonds]: compound->getBonds()){
        
    } 

    
    compoundsOnScreen.push_back(this);
}

CompoundObject::CompoundObject(int compoundNumber,char dummy){

}

CompoundObject::~CompoundObject(){

}

std::vector<CompoundObject*> CompoundObject::getListOfCompoundObjects(){

}
#include "elementRender.h"

ElementObject::ElementObject(Element* element){


}

void ElementObject::drawElement(){

}

void ElementObject::drawElectronsAndBondsOfElement(){

}

void ElementObject::Inserelementiselementobject(){

}
 
     // int width;
    // for(auto el: compound->getAtoms()){
    //     if(el->getSymbol().size()==1){
    //         width=elementSingleTextureWidth;
    //     }
    //     else if(el->getSymbol().size()==2){
    //         width=elementDoubleTextureWidth;
    //     }
    //     else{
    //         //error
    //     }
    //     vertices={
    //         defaultSpawnLocation.x,defaultSpawnLocation.y ,0.0f,0.0f,
    //         defaultSpawnLocation.x+((width/io.DisplaySize.x )*2),defaultSpawnLocation.y ,1.0f,0.0f,
    //         defaultSpawnLocation.x+((width/io.DisplaySize.x )*2),defaultSpawnLocation.y +((elementTextureHeight/io.DisplaySize.y )*2)     ,1.0f,1.0f,
    //         defaultSpawnLocation.x,defaultSpawnLocation.y +((elementTextureHeight/io.DisplaySize.y )*2)     ,0.0f,1.0f,
    //     };
    //    //no do a traversal here so we dont have overlaps but for now idc
    //    //change values for sdjustment
    //     auto elObj= new ElementObject(vertices,indices,el);
    //     defaultSpawnLocation.x+=(width/io.DisplaySize.x )*2.5;
    //     //defaultSpawnLocation.y+=(elementTextureHeight/io.DisplaySize.y )*2.5;
    // }


    //dynamically add 
    // "water", "carbon dioxide", "carbon monoxide", "hydrogen peroxide", "ozone", "ammonia", "nitrogen dioxide", "benzene", "table salt", "acetic acid", "vinegar", "baking soda", "bleach", "limestone", "washing soda", "alcohol"
    std::map<std::string,std::string> molecules={
    {"Water","1&1.000000&0/8&16.000000&0/1&1.000000&0/;1&0)/0&0)2&0)/1&0)/"},
    {"Carbon Dioxide","6&12.000000&0/8&16.000000&0/8&16.000000&0/;1&0)2&0)1&0)2&0)/0&0)0&0)/0&0)0&0)/"},
    {"Carbon Monoxide","6&12.000000&0/8&16.000000&0/;1&0)1&0)1&-2)/0&0)0&0)0&2)/"},
    {"Hydrogen Peroxide","1&1.000000&0/8&16.000000&0/8&16.000000&0/1&1.000000&0/;1&0)/0&0)2&0)/1&0)3&0)/2&0)/"},
    {"Ozone","8&16.000000&-1/8&16.000000&1/8&16.000000&0/;1&0)/0&0)2&0)2&0)/1&0)1&0)/"},
    {"Ammonia","7&14.000000&0/1&1.000000&0/1&1.000000&0/1&1.000000&0/;1&0)2&0)3&0)/0&0)/0&0)/0&0)/"},
    {"Nitrogen Dioxide", "7&14.000000&1/8&16.000000&-1/8&16.000000&0/;1&0)2&0)2&0)/0&0)/0&0)0&0)/"},
    {"Benzene","6&12.000000&0/6&12.000000&0/6&12.000000&0/6&12.000000&0/6&12.000000&0/6&12.000000&0/1&1.000000&0/1&1.000000&0/1&1.000000&0/1&1.000000&0/1&1.000000&0/1&1.000000&0/;1&0)5&0)5&0)6&0)/0&0)2&0)2&0)7&0)/1&0)3&0)1&0)8&0)/2&0)4&0)4&0)9&0)/3&0)5&0)3&0)10&0)/4&0)0&0)0&0)11&0)/0&0)/1&0)/2&0)/3&0)/4&0)/5&0)/"},
    {"Table Salt","11&23.000000&0/17&35.500000&0/;1&1)/0&-1)/"},
    {"Vinegar","6&12.000000&0/1&1.000000&0/1&1.000000&0/1&1.000000&0/6&12.000000&0/8&16.000000&0/8&16.000000&0/1&1.000000&0/;1&0)2&0)3&0)4&0)/0&0)/0&0)/0&0)/0&0)5&0)5&0)6&0)/4&0)4&0)/4&0)7&0)/6&0)/"},
    {"Acetic Acid","6&12.000000&0/1&1.000000&0/1&1.000000&0/1&1.000000&0/6&12.000000&0/8&16.000000&0/8&16.000000&0/1&1.000000&0/;1&0)2&0)3&0)4&0)/0&0)/0&0)/0&0)/0&0)5&0)5&0)6&0)/4&0)4&0)/4&0)7&0)/6&0)/"},
    {"Baking Soda","6&12.000000&0/8&16.000000&0/8&16.000000&0/1&1.000000&0/8&16.000000&0/11&23.000000&0/;1&0)1&0)2&0)4&0)/0&0)0&0)/0&0)3&0)/2&0)/0&0)5&-1)/4&1)/"},
    {"Limestone","6&12.000000&0/8&16.000000&0/8&16.000000&0/8&16.000000&0/20&40.000000&0/;1&0)1&0)2&0)3&0)/0&0)0&0)/0&0)4&-1)/0&0)4&-1)/2&1)3&1)/"},
    {"Bleach","17&35.500000&0/8&16.000000&0/11&23.000000&0/;1&0)/0&0)2&-1)/1&1)/"},
    {"Washing Soda","6&12.000000&0/8&16.000000&0/8&16.000000&0/8&16.000000&0/11&23.000000&0/11&23.000000&0/;1&0)1&0)2&0)3&0)/0&0)0&0)/0&0)4&-1)/0&0)5&-1)/2&1)/3&1)/"},
    {"Alcohol","6&12.000000&0/1&1.000000&0/1&1.000000&0/1&1.000000&0/6&12.000000&0/1&1.000000&0/1&1.000000&0/8&16.000000&0/1&1.000000&0/;1&0)2&0)3&0)4&0)/0&0)/0&0)/0&0)/0&0)5&0)6&0)7&0)/4&0)/4&0)/4&0)8&0)/7&0)/"}

// std::vector<std::string> compoundNumbers={"Water", "Carbon Dioxide", "Carbon Monoxide", "Hydrogen Peroxide", "Ozone", "Ammonia", "Nitrogen Dioxide", "Benzene", "Table Salt", "Vinegar", "Acetic Acid", "Baking Soda", "Limestone", "Bleach", "Washing Soda", "Alcohol"};
