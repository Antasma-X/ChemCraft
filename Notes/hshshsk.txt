CC=g++
Cflags= -Wall -g --std=c++17 
LIB = build/imgui.o

all: main

main: build/element.o build/values.o build/main.o build/compound.o build/molecules.o
	$(CC) $(Cflags) -o $@ $^

cute: build/element.o build/values.o build/test.o build/compound.o build/molecules.o
	$(CC) $(Cflags) -o $@ $^

build/element.o: src/element.cpp
	$(CC) $(Cflags) -o $@ -c $^

build/values.o: src/values.cpp
	$(CC) $(Cflags) -o $@ -c $^

build/compound.o: src/compound.cpp
	$(CC) $(Cflags) -o $@ -c $^

build/test.o: test/test.cpp
	$(CC) $(Cflags) -o $@ -c $^

build/imgui.o: lib/imgui/src/imgui_demo.cpp lib/imgui/src/imgui_draw.cpp lib/imgui/src/imgui/imgui_impl_glfw.cpp lib/imgui/src/imgui_opengl3.cpp lib/imgui/src/imgui_tables.cpp lib/imgui/src/imgui_widgets.cpp lib/imgui/src/imgui.cpp
	$(CC) $(Cflags) -o $@ -c $^
build/molecules.o: src/molecules.cpp
	$(CC) $(Cflags) -o $@ -c $^
clean:
	rm build/*.o main cute

test:

lib/imgui/src/imgui/imgui_impl_glfw.cpplib/imgui/src/imgui_opengl3.cpp

imgui_demo.cpp imgui_draw.cpp imgui_impl_glfw.cpp imgui_impl_opengl3.cpp imgui_tables.cpp imgui_widgets.cpp imgui.cpp

target_include_directories(imgui 
    INTERFACE
    ${CMAKE_CURRENT_SOURCE_DIR})

// Compound* makeMolecule(std::string name){
//     return makeMolecule(molecules[name]);
// }

// Compound* makeMolecule(int n){

//     Compound* newCompound=nullptr;
    
//     if(n==1){
//         Element* H1=new Element(1);
//         Element* H2=new Element(1);
//         Element* O=new Element(8);

//         newCompound=new Compound(*H1);
//         newCompound->addElement(*H1,*O,0);
//         newCompound->addElement(*O,*H2,0);
        
//     }
//     else if(n==2){
//         Element* O1=new Element(8);
//         Element* O2=new Element(8);
//         Element* C=new Element(6);            

//         newCompound=new Compound(*C);
//         newCompound->addElement(*C,*O1,0);
//         newCompound->addElement(*C,*O2,0);
//     }
//     else if(n==3){
//         Element* O=new Element(8);
//         Element* C=new Element(6);            

//         newCompound=new Compound(*C);
//         newCompound->addElement(*C,*O,0);
//     } 
//     else if(n==4){
//         Element* H1=new Element(1);
//         Element* H2=new Element(1);
//         Element* O1=new Element(8);
//         Element* O2=new Element(8);

//         newCompound=new Compound(*H1);
//         newCompound->addElement(*H1,*O1,0);
//         newCompound->addElement(*O1,*O2,0);
//         newCompound->addElement(*O2,*H2,0);
//     }
//     else if(n==5){
//         Element* O1=new Element(8);
//         Element* O2=new Element(8);
//         Element* O3=new Element(8);

//         newCompound=new Compound(*O1);
//         newCompound->addElement(*O1,*O2,0);
//         newCompound->addElement(*O2,*O3,0);
//         newCompound->createBond(*O1,*O3,0);
//     }
//     else if(n==6){
//         Element* N=new Element(7);
//         Element* H1=new Element(1);
//         Element* H2=new Element(1);
//         Element* H3=new Element(1);

//         newCompound=new Compound(*N);
//         newCompound->addElement(*N,*H1,0);
//         newCompound->addElement(*N,*H2,0);
//         newCompound->addElement(*N,*H3,0);
//     }
//     else if(n==7){
//         Element* N=new Element(7);
//         Element* O1=new Element(8);
//         Element* O2=new Element(8);

//         newCompound=new Compound(*N);
//         newCompound->addElement(*N,*O1,0);
//         newCompound->addElement(*N,*O2,0);
//         newCompound->createBond(*N,*O1,0);         
//     }
//     else if(n==8){
//         Element* C1=new Element(6);
//         Element* C2=new Element(6);
//         Element* C3=new Element(6);
//         Element* C4=new Element(6);
//         Element* C5=new Element(6);
//         Element* C6=new Element(6);

//         Element* H1=new Element(1);
//         Element* H2=new Element(1);
//         Element* H3=new Element(1);
//         Element* H4=new Element(1);
//         Element* H5=new Element(1);
//         Element* H6=new Element(1);

//         newCompound=new Compound(*C1);
//         newCompound->addElement(*C1,*C2,0);
//         newCompound->addElement(*C2,*C3,0);
//         newCompound->addElement(*C3,*C4,0);
//         newCompound->addElement(*C4,*C5,0);
//         newCompound->addElement(*C5,*C6,0);

//         newCompound->createBond(*C2,*C3,0);
//         newCompound->createBond(*C4,*C5,0);
//         newCompound->createBond(*C6,*C1,0);

//         newCompound->addElement(*C1,*H1,0);
//         newCompound->addElement(*C2,*H2,0);
//         newCompound->addElement(*C3,*H3,0);
//         newCompound->addElement(*C4,*H4,0);
//         newCompound->addElement(*C5,*H5,0);
//         newCompound->addElement(*C6,*H6,0);
//     }
//     else{
        
//     }
//     return newCompound;
    
// }


// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeAnion(std::string name){
//     return makeAnion(anions[name]);
// }

// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeAnion(int n){
//     Compound* newCompound=nullptr;
//     std::vector<Element*> elements;
//     std::vector<int> valencies;
    
//     if(n==1){
//         Element* F= new Element(9);

//         elements.emplace_back(F);
//         valencies.emplace_back(-1);

//         newCompound= new Compound(*F);
//     }
//     else if(n==2){
//         Element* Cl= new Element(17);

//         elements.emplace_back(Cl);
//         valencies.emplace_back(-1);

//         newCompound= new Compound(*Cl);
//     }
//     else if(n==3){
//         Element* Br= new Element(35);

//         elements.emplace_back(Br);
//         valencies.emplace_back(-1);

//         newCompound= new Compound(*Br);
//     }
//     else if(n==4){
//         Element* I= new Element(53);

//         elements.emplace_back(I);
//         valencies.emplace_back(-1);

//         newCompound= new Compound(*I);
//     }
//     else if(n==5){
//         Element* S = new Element(16);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);
//         Element* O3 = new Element(8);
//         Element* O4 = new Element(8);

//         newCompound=new Compound(*S);
//         newCompound->addElement(*S,*O1,0);
//         newCompound->addElement(*S,*O2,0);
//         newCompound->addElement(*S,*O3,0);
//         newCompound->addElement(*S,*O4,0);

//         newCompound->createBond(*S,*O2,0);
//         newCompound->createBond(*S,*O4,0);

//         elements.emplace_back(O1);
//         valencies.emplace_back(-1);

//         elements.emplace_back(O3);
//         valencies.emplace_back(-1);
//     }
//     else if(n==6){
//         Element* S = new Element(16);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);
//         Element* O3 = new Element(8);

//         newCompound=new Compound(*S);
//         newCompound->addElement(*S,*O1,0);
//         newCompound->addElement(*S,*O2,0);
//         newCompound->addElement(*S,*O3,0);

//         newCompound->createBond(*S,*O2,0);

//         elements.emplace_back(O1);
//         valencies.emplace_back(-1);

//         elements.emplace_back(O3);
//         valencies.emplace_back(-1);
        
//     }
//     else if(n==7){
//         Element* C = new Element(6);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);
//         Element* O3 = new Element(8);

//         newCompound=new Compound(*C);
//         newCompound->addElement(*C,*O1,0);
//         newCompound->addElement(*C,*O2,0);
//         newCompound->addElement(*C,*O3,0);
//         newCompound->createBond(*C,*O2,0);

//         elements.emplace_back(O1);
//         valencies.emplace_back(-1);

//         elements.emplace_back(O3);
//         valencies.emplace_back(-1);
//     }
//     else if(n==8){
//         Element* C = new Element(6);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);
//         Element* O3 = new Element(8);
//         Element* H = new Element(1);

//         newCompound=new Compound(*C);
//         newCompound->addElement(*C,*O1,0);
//         newCompound->addElement(*C,*O2,0);
//         newCompound->addElement(*C,*O3,0);
//         newCompound->addElement(*O1,*H,0);
//         newCompound->createBond(*C,*O2,0);     

//         elements.emplace_back(O3);
//         valencies.emplace_back(-1);
//     }
//     else if(n==9){
//         Element* N = new Element(7);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);
//         Element* O3 = new Element(8);

//         newCompound=new Compound(*N);
//         newCompound->addElement(*N,*O1,0);
//         newCompound->addElement(*N,*O2,0);
//         newCompound->addElement(*N,*O3,0);
//         newCompound->createBond(*N,*O2,0);

//         elements.emplace_back(O3);
//         valencies.emplace_back(-1);
//     }
//     else if(n==10){
//         Element* N = new Element(7);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);

//         newCompound=new Compound(*N);
//         newCompound->addElement(*N,*O1,0);
//         newCompound->addElement(*N,*O2,0);
//         newCompound->createBond(*N,*O2,0);       

//         elements.emplace_back(O1);
//         valencies.emplace_back(-1);
//     }
//     else if(n==11){
//         Element* P = new Element(15);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);
//         Element* O3 = new Element(8);
//         Element* O4= new Element(8);

//         newCompound=new Compound(*P);
//         newCompound->addElement(*P,*O1,0);
//         newCompound->addElement(*P,*O2,0);
//         newCompound->addElement(*P,*O3,0);
//         newCompound->addElement(*P,*O4,0);
//         newCompound->createBond(*P,*O4,0);           

//         elements.emplace_back(O1);
//         valencies.emplace_back(-1);

//         elements.emplace_back(O2);
//         valencies.emplace_back(-1);

//         elements.emplace_back(O3);
//         valencies.emplace_back(-1);
//     }
//     else if(n==12){
//         Element* P = new Element(15);
//         Element* O1 = new Element(8);
//         Element* O2= new Element(8);
//         Element* O3 = new Element(8);


//         newCompound=new Compound(*P);
//         newCompound->addElement(*P,*O1,0);
//         newCompound->addElement(*P,*O2,0);
//         newCompound->addElement(*P,*O3,0);

//         elements.emplace_back(O1);
//         valencies.emplace_back(-1);

//         elements.emplace_back(O2);
//         valencies.emplace_back(-1);

//         elements.emplace_back(O3);
//         valencies.emplace_back(-1);
//     }
//     else if(n==13){
//         Element* O = new Element(8);
//         Element* H = new Element(1);  
//         newCompound=new Compound(*O);
//         newCompound->addElement(*O,*H,0);         

//         elements.emplace_back(O);
//         valencies.emplace_back(-1);
//     }
//     else{
//         //error
//     }


    
//     std::pair<Compound*,std::vector<std::pair<Element*,int>>> info;
//     info.first=newCompound;

// //     for(std::size_t i=0;i<elements.size();i++){
// //         info.second[i]=std::make_pair(elements[i],valencies[i]);
// //     }
    
// //     return info;
// // }


// Compound* makeAnion(int n){
//         Compound* newCompound=nullptr;
        
//         if(n==1){
//             Element* F= new Element(9);
    
//             elements.emplace_back(F);
//             valencies.emplace_back(-1);
    
//             newCompound= new Compound(*F);
//         }
//         else if(n==2){
//             Element* Cl= new Element(17);
    
//             elements.emplace_back(Cl);
//             valencies.emplace_back(-1);
    
//             newCompound= new Compound(*Cl);
//         }
//         else if(n==3){
//             Element* Br= new Element(35);
    
//             elements.emplace_back(Br);
//             valencies.emplace_back(-1);
    
//             newCompound= new Compound(*Br);
//         }
//         else if(n==4){
//             Element* I= new Element(53);
    
//             elements.emplace_back(I);
//             valencies.emplace_back(-1);
    
//             newCompound= new Compound(*I);
//         }
//         else if(n==5){
//             Element* S = new Element(16);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
//             Element* O3 = new Element(8);
//             Element* O4 = new Element(8);
    
//             newCompound=new Compound(*S);
//             newCompound->addElement(*S,*O1,0);
//             newCompound->addElement(*S,*O2,0);
//             newCompound->addElement(*S,*O3,0);
//             newCompound->addElement(*S,*O4,0);
    
//             newCompound->createBond(*S,*O2,0);
//             newCompound->createBond(*S,*O4,0);
    
//             elements.emplace_back(O1);
//             valencies.emplace_back(-1);
    
//             elements.emplace_back(O3);
//             valencies.emplace_back(-1);
//         }
//         else if(n==6){
//             Element* S = new Element(16);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
//             Element* O3 = new Element(8);
    
//             newCompound=new Compound(*S);
//             newCompound->addElement(*S,*O1,0);
//             newCompound->addElement(*S,*O2,0);
//             newCompound->addElement(*S,*O3,0);
    
//             newCompound->createBond(*S,*O2,0);
    
//             elements.emplace_back(O1);
//             valencies.emplace_back(-1);
    
//             elements.emplace_back(O3);
//             valencies.emplace_back(-1);
            
//         }
//         else if(n==7){
//             Element* C = new Element(6);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
//             Element* O3 = new Element(8);
    
//             newCompound=new Compound(*C);
//             newCompound->addElement(*C,*O1,0);
//             newCompound->addElement(*C,*O2,0);
//             newCompound->addElement(*C,*O3,0);
//             newCompound->createBond(*C,*O2,0);
    
//             elements.emplace_back(O1);
//             valencies.emplace_back(-1);
    
//             elements.emplace_back(O3);
//             valencies.emplace_back(-1);
//         }
//         else if(n==8){
//             Element* C = new Element(6);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
//             Element* O3 = new Element(8);
//             Element* H = new Element(1);
    
//             newCompound=new Compound(*C);
//             newCompound->addElement(*C,*O1,0);
//             newCompound->addElement(*C,*O2,0);
//             newCompound->addElement(*C,*O3,0);
//             newCompound->addElement(*O1,*H,0);
//             newCompound->createBond(*C,*O2,0);     
    
//             elements.emplace_back(O3);
//             valencies.emplace_back(-1);
//         }
//         else if(n==9){
//             Element* N = new Element(7);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
//             Element* O3 = new Element(8);
    
//             newCompound=new Compound(*N);
//             newCompound->addElement(*N,*O1,0);
//             newCompound->addElement(*N,*O2,0);
//             newCompound->addElement(*N,*O3,0);
//             newCompound->createBond(*N,*O2,0);
    
//             elements.emplace_back(O3);
//             valencies.emplace_back(-1);
//         }
//         else if(n==10){
//             Element* N = new Element(7);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
    
//             newCompound=new Compound(*N);
//             newCompound->addElement(*N,*O1,0);
//             newCompound->addElement(*N,*O2,0);
//             newCompound->createBond(*N,*O2,0);       
    
//             elements.emplace_back(O1);
//             valencies.emplace_back(-1);
//         }
//         else if(n==11){
//             Element* P = new Element(15);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
//             Element* O3 = new Element(8);
//             Element* O4= new Element(8);
    
//             newCompound=new Compound(*P);
//             newCompound->addElement(*P,*O1,0);
//             newCompound->addElement(*P,*O2,0);
//             newCompound->addElement(*P,*O3,0);
//             newCompound->addElement(*P,*O4,0);
//             newCompound->createBond(*P,*O4,0);           
    
//             elements.emplace_back(O1);
//             valencies.emplace_back(-1);
    
//             elements.emplace_back(O2);
//             valencies.emplace_back(-1);
    
//             elements.emplace_back(O3);
//             valencies.emplace_back(-1);
//         }
//         else if(n==12){
//             Element* P = new Element(15);
//             Element* O1 = new Element(8);
//             Element* O2= new Element(8);
//             Element* O3 = new Element(8);
    
    
//             newCompound=new Compound(*P);
//             newCompound->addElement(*P,*O1,0);
//             newCompound->addElement(*P,*O2,0);
//             newCompound->addElement(*P,*O3,0);
    
//             elements.emplace_back(O1);
//             valencies.emplace_back(-1);
    
//             elements.emplace_back(O2);
//             valencies.emplace_back(-1);
    
//             elements.emplace_back(O3);
//             valencies.emplace_back(-1);
//         }
//         else if(n==13){
//             Element* O = new Element(8);
//             Element* H = new Element(1);  
//             newCompound=new Compound(*O);
//             newCompound->addElement(*O,*H,0);         
    
//             elements.emplace_back(O);
//             valencies.emplace_back(-1);
//         }
//         else{
//             //error
//         }
    
    
        
//         std::pair<Compound*,std::vector<std::pair<Element*,int>>> info;
//         info.first=newCompound;
    
// //         for(std::size_t i=0;i<elements.size();i++){
// //             info.second[i]=std::make_pair(elements[i],valencies[i]);
// //         }
        
// //         return info;
// //     }

// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeCation(std::string name,int valency){

//     auto it=std::find(names.begin(),names.end(),name);
//     int n;
//     if(it==names.end()){
//         auto i=cations.find(name);
//         if(i == cations.end()){
//             n=0;

//         }
//         else{
//             n=std::distance(cations.begin(),i)+1;
//         }
//     }
//     else{
//         n=std::distance(names.begin(),it)+1;

//     }
//     return makeCation(n,valency);
// }

// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeCation(int n,int valency){
//     Compound* newCompound=nullptr;
//     std::vector<Element*> elements;
//     std::vector<int> valencies;

//     if(n>=1 && n<=118){
//         Element* element1=new Element(n);
//         newCompound=new Compound(*element1);

//         elements.emplace_back(element1);
//         valencies.emplace_back(valency);
//     }
//     else{
//         // switch(n){
//         //     case 200:
//         //         //ammonium
//         //     case 201:
//         //     //hydronium
//         // }
//     }
//         std::pair<Compound*,std::vector<std::pair<Element*,int>>> info;
//     info.first=newCompound;

//     for(size_t i=0;i<elements.size();i++){
//         info.second[i]=std::make_pair(elements[i],valencies[i]);
//     }

    
//     return info;
// }

// std::array<std::string,3> splitSaltName(std::string name){
//     std::array<std::string,3> sections;
//     int i =0;
//     std::string space=" ";
//     for(int j=0;j<3;j++){
//         while(name[i] !=' '){
//             sections[i]+=name[i];
//             i++;
//         }
//         i++;
//     }
//     return sections;
// }

// //yoink
// int value(char r)
// {
//     if (r == 'I')
//         return 1;
//     if (r == 'V')
//         return 5;
//     if (r == 'X')
//         return 10;
//     if (r == 'L')
//         return 50;
//     if (r == 'C')
//         return 100;
//     if (r == 'D')
//         return 500;
//     if (r == 'M')
//         return 1000;
 
//     return -1;
// }
 



// Compound* makeSalt(std::string name){
//     std::array<std::string,3> sections=splitSaltName(name);
//     int n=romanToDecimal(sections[1]);

//     std::pair<Compound*,std::vector<std::pair<Element*,int>>> anion= makeAnion(sections[2]);
//     std::pair<Compound*,std::vector<std::pair<Element*,int>>> cation=makeCation(sections[0],n);

//     int totalAnionValency=0;
//     int totalCationValency=0;

//     for(auto el:anion.second){
//         totalAnionValency+=el.second;
//     }

//     for(auto el:cation.second){
//         totalCationValency+=el.second;
//     }

//     int lcm=std::lcm(abs(totalAnionValency),totalCationValency);

//     std::vector<std::pair<Compound*,std::vector<std::pair<Element*,int>>>> anions={anion};
//     std::vector<std::pair<Compound*,std::vector<std::pair<Element*,int>>>> cations={cation};

//     for(int i=0;i<(lcm/totalCationValency)-1;i++){
//         cations.emplace_back(makeCation(sections[0],n));
//     }

//     for(int i=0;i<(lcm/abs(totalAnionValency))-1;i++){
//         anions.emplace_back(makeAnion(sections[0]));
//     }


//     //code is built on hopes and prayers
//     int i=0;
//     int j=0;
//     size_t k=0;

//     for(auto anion:anions){
//         for(int l=0;l<abs(totalAnionValency);i++){
//             if(anion.second[i].second !=0){
                
//                 anion.second[i].second++;
//                 cations[j].second[k].second--;
//                 anion.first->addElement(*anion.second[i].first,*cations[j].second[k].first,*cations[j].first,-1);

//                 while (true){
//                     if(cations[j].second[k].second==0){
//                         if(cations[j].second.size()==k-1){
//                             j++;
//                             k=0;
//                         }
//                         else{
//                             k++;
//                         }
//                     }
//                     else{
//                         break;
//                     }
//                 }
//             }
//             else{
//                 i++;
//             }
//         }
//     }

//     return anion.first;
// }



// Compound* makeMolecule(int n);



// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeAnion(std::string name);

// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeAnion(int n);

// //1-118 for elelemnts than actual ions
// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeCation(std::string name,int valency);

// std::pair<Compound*,std::vector<std::pair<Element*,int>>> makeCation(int n,int valency);

//stock notation



// std::map<std::string,int> molecules={
//     {"Water",1},
//     {"Carbon Dioxide",2},
//     {"Carbon Monoxide",3},
//     {"Hydrogen Peroxide",4},
//     {"Ozone",5},
//     {"Ammonia",6},
//     {"Nitrogen Dioxide", 7},
//     {"Benzene",8}

// };

        // std::cout<<io.DisplaySize.y<<std::endl;
        // if(prevWindowSize.y!=io.DisplaySize.y){
        //     io.Fonts->Clear(); 
        //     io.Fonts->AddFontFromFileTTF("/mnt/c/Windows/Fonts/arial.ttf", 18.0f);
        //     myFont= io.Fonts->AddFontFromFileTTF("/mnt/c/Windows/Fonts/arial.ttf", searchBarHeightPerCent*io.DisplaySize.y);
        //     io.Fonts->Build();
        //     ImGui_ImplOpenGL3_DestroyFontsTexture();
        //     ImGui_ImplOpenGL3_CreateFontsTexture();
        // }
        




// Compound::Compound(Compound&& other) {
//         atoms=other.atoms;
// 		bonds=other.bonds;
//     }

// Compound::Compound(const Compound& other){
// 	atoms=other.atoms;
// 	bonds=other.bonds;
// }